# BAEKJOON ONLINE JUDGE - 1300. K번째 수

* [문제출처](https://www.acmicpc.net/problem/1300 "1300. K번째 수")

## 알고리즘 분류
- 이분 탐색
- 매개 변수 탐색

## 풀이(1차)
### 접근
- 리스트 정렬

### 설계
- 나올 수 있는 모든 경우의 수를 리스트에 저장하고 리스트 정렬
- `k`인덱스의 수 출력
- 메모리 초과

## 풀이(2차)
### 접근
- 리스트의 크기가 너무 커서 메모리 초과 발생
- 리스트를 만들지 않고 `k`번째까지 경우의 수를 구하면서 결과 도출

### 설계
- `i`가 1일때부터 나올수 있는 결과는 `i`와 `j`가 같은 경우를 빼고 2개씩 발생한다.(`i`와 `j`를 교체한 자리에도 같은 수가 저장됨)
- `cnt+1+2*(n-i-1)`가 `k`보다 작으면 그대로 `cnt`에 저장하고 `i`를 1 증가시킨다.
- 아니라면 그 행에 `k`번째 수가 있다고 가정하고 `i ~ n`까지의 경우를 계산하고 `k`번째 수를 출력한다.
- 오답

## 풀이(3차)
### 접근
- 위의 경우는 이전의 열들은 다음 열보다 큰 값이 존재하지 않는다는 가정으로 설계 -> 가정이 틀림
- 책 참고
- `k`번째 수는 `k`보다 크지 않음을 이용(배열은 `1 ~ n`까지 `1 ~ n`의 배수로 이루어져 있기 때문에 중복되는 수(`1*2 & 2*1`...)가 발생하면서 `k`번째 수는 `k`보다 작거나 같을 수 밖에 없음)
- 시작 인덱스와 종료 인덱스를 `1, k`로 정의하고 중앙값 `mid = (s + e) // 2`로 정의하여 중앙값으로 `k`를 탐색
- 각 행마다 중앙값보다 작거나 같은 경우의 수는 `mid // row`이지만 배열의 크기보다 클 수 있기 때문에 `min(mid // row, n)`으로 정의
- 모든 행을 탐색했을 때 중앙값 이하의 수가 `k`보다 작다면 시작 인덱스를 `mid + 1`로 교체하고, `k`보다 크거나 같다면 결과값을 중앙값으로 업데이트하고 종료 인덱스를 `mid - 1`로 교체한다.
- 시작 인덱스가 종료 인덱스보다 커지면 반복문을 종료하고 결과값을 출력한다.