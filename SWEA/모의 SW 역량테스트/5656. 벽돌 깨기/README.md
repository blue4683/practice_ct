# SW Expert Academy - 5656. 벽돌 깨기

* [문제출처](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRQm6qfL0DFAUo "[모의 SW 역량테스트] 벽돌 깨기")

## 풀이
### 설계
- 구슬을 쏘는 경우는 `DFS`로, 벽돌이 깨진 후는 `BFS`로 구현
- 입력받은 벽돌을 전치하여 사용한다.(왼쪽에 `0`이 쌓이고 오른쪽이 밑인 이차 배열을 생성)
- 초기 결과값은 입력받은 벽돌의 개수로 정의한다.
- 재귀함수를 통해 구슬을 쏘는 경우의 수를 구한다.
- 구슬을 다 쏘기 전에 벽돌이 없다면 결과값에 `0`을 저장하고 재귀를 종료한다.
- 구슬을 다 쏘면 벽돌의 개수를 세고 결과값과 비교하여 저장하고 재귀를 종료한다.
- 왼쪽부터 경우의 수를 탐색한다. 가장 위에 있는 벽돌을 찾으면 벽돌이 부서지는 구현을 하는 함수(`crack`)를 호출한다.
- 함수에 벽돌의 위치, 벽돌의 폭발 범위, `deepcopy`한 벽돌 이차원 배열(원본이 바뀌는 것을 방지), 방문 배열을 입력한다.
- `BFS`로 벽돌이 폭발하는 곳을 모두 탐색하고 방문 배열에 체크한다.
- 방문 배열에 체크되어있는 위치의 벽돌을 모두 0으로 바꾼다.
- 그 후 벽돌이 밑으로 떨어지는 것을 반영하기 위해 0이 아닌 값을 추출하여 리스트에 저장하고 `h`길이가 되게끔 앞에 `0`으로 채운다.
- 깨진 벽돌을 반영한 새로운 이차원 배열을 반환하여 재귀함수(`shoot`)에 입력하고 재귀한다.

### 고찰
- 벽돌이 밑으로 떨어지는 것을 반영하는 방법으로 처음에는 `deque`을 사용하여 `0`이 없어질때까지 `while`문을 돌리고, 그 후에 `appendleft(0)`을 통해 채웠다.
- 이렇게 수행하게되면 반복문이 도는 중 `0`이 사라지면 그 상태로 반복문이 종료되기 때문에 벽돌의 순서가 달라질 수 있으므로 정답이 나오지 않았다.
- `deepcopy`를 쓰지 않고 리스트 슬라이싱을 통해 배열을 복사하면 실행시간을 줄일 수 있었다.